package com.londonhydro.api.interceptors;

import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.security.DenyAll;
import javax.annotation.security.PermitAll;
import javax.annotation.security.RolesAllowed;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Cookie;
import javax.ws.rs.ext.Provider;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.jboss.resteasy.annotations.interception.Precedence;
import org.jboss.resteasy.annotations.interception.ServerInterceptor;
import org.jboss.resteasy.core.ResourceMethod;
import org.jboss.resteasy.core.ServerResponse;
import org.jboss.resteasy.spi.Failure;
import org.jboss.resteasy.spi.HttpRequest;
import org.jboss.resteasy.spi.interception.PreProcessInterceptor;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Key;
import com.google.inject.name.Names;
import com.londonhydro.api.annotations.Verifier;
import com.londonhydro.api.auth.ApiTransaction;
import com.londonhydro.api.auth.UserContextHolder;
import com.londonhydro.api.cache.BasicCache;
import com.londonhydro.api.manager.UserAccountManager;
import com.londonhydro.model.Role;
import com.londonhydro.model.Role.Roles;
import com.londonhydro.model.UserAccount;
import com.londonhydro.model.UserAccountToken;
import com.londonhydro.utils.exception.impl.CustomWebApplicationException;
import com.londonhydro.utils.log.Log;
import com.londonhydro.utils.response.logger.RequestLogger;

/**
 * This class is in charge of check the authorization token and see if the user
 * is able to make a request.
 * 
 * @author Juan Pablo Francisconi (jpfrancisconi@affsys.com)
 */
@Provider
@ServerInterceptor
@Precedence(value = "SECURITY")
public class SecurityInterceptor implements PreProcessInterceptor
{

    private static final com.affsys.gae.log.Log logger = Log.INTERCEPTOR;

    private static final String SESSION_HEADER = "authorization";
    private static final String SPECIAL_DISCOVERY_PREFIX = "discover";
    private static final String SPECIAL_PUBLIC_PREFIX = "public";
	private static final String SPECIAL_CRONS_PREFIX = "crons";
	private static final String SPECIAL_QUEUES_PREFIX = "queues";
	private static final String SPECIAL_CMS_PREFIX = "cms";
	@Context
	private HttpServletRequest req;
	
    @Inject
    private Injector injector;
	
    @Inject
    private UserAccountManager userAccountManager;
    private UserContextHolder userContextHolder;

    @Override
    public ServerResponse preProcess(HttpRequest request, ResourceMethod method) throws Failure, WebApplicationException
    {
        ServerResponse response = null;
        Long requestId = RequestLogger.getInstance().getLogger().incrementRequestId();
        logger.info("Security Interceptor: Processing request #%d", requestId);
        
//        StatsLogger.getInstance().getStatsBuffer().setTitle("Request-"+requestId);
//        StatsLogger.getInstance().getStatsBuffer().getBuffer().append(" ******************************** \n");
//        StatsLogger.getInstance().getStatsBuffer().getBuffer().append(" URL: "+request.getUri().getPath()+"\n");
//        
        if (request.getPreprocessedPath().contains(SPECIAL_QUEUES_PREFIX) || request.getPreprocessedPath().contains(SPECIAL_CRONS_PREFIX) || request.getPreprocessedPath().contains(SPECIAL_CMS_PREFIX) || request.getPreprocessedPath().contains(SPECIAL_PUBLIC_PREFIX) || request.getPreprocessedPath().contains(SPECIAL_DISCOVERY_PREFIX) || request.getHttpMethod().equalsIgnoreCase("OPTIONS"))
        {
            return response;
        }
        authenticateUser(request, requestId, method);
        return response;
    }
    
    
    /**
     * Handle User Authentication
     * 
     * @param token
     * @param request
     * @param requestId
     * @throws CustomWebApplicationException
     */
    private void authenticateUser(HttpRequest request, Long requestId, ResourceMethod method) throws WebApplicationException
    {
    	List<String> authentication = request.getHttpHeaders().getRequestHeader(SESSION_HEADER);
        Map<String, Cookie> cookies = request.getHttpHeaders().getCookies();
        UserAccount userAccount = null;
        
        if (authentication != null)
        {
            logger.info("== authorization : %s ", authentication);
            String authValue = authentication.get(0);
            if(authValue.contains("Bearer") || authValue.contains("bearer"))
            {
                String splitter = authValue.contains("Bearer") ? "Bearer":"bearer";
                String value = authValue.split(splitter)[1];
                
                if(value.trim().equals("-dt01")) 
                {
                    List<UserAccount> accounts = userAccountManager.listUserAccounts(null, "integration-test", null);
                    if (accounts != null && accounts.size() > 0)
                        userAccount = accounts.get(accounts.size() - 1);
                    else
                        throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user not authorized ");
                }
                else
                {
                    UserAccountToken accountToken = userAccountManager.getUserAccountToken(value.trim());
                    if (accountToken == null)
                        throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user not authorized ");
                
                    userAccount = accountToken.getAccount();
                    checkUserRoles(accountToken.getAccount(), method, requestId);
                }
                
            }
            else if(cookies!=null && cookies.get("user-token")!=null)
            {
                Cookie cookie = cookies.get("user-token");
                String value = cookie.getValue();
                
                UserAccountToken accountToken = userAccountManager.getUserAccountToken(value.trim());
                if (accountToken == null)
                    throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user not authorized ");
            
                userAccount = accountToken.getAccount();
                checkUserRoles(accountToken.getAccount(), method, requestId);
                userContextHolder = new UserContextHolder(userAccount);
                request.setAttribute(Key.get(UserContextHolder.class, Names.named("userContextHolder")).toString(), userContextHolder);
                request.setAttribute(Key.get(ApiTransaction.class, Names.named("transaction")).toString(), new ApiTransaction(userAccount));
                setBasicCache();
            }
            else if (authValue.contains("Basic") || authValue.contains("basic"))
            {
                String splitter = authValue.contains("Basic") ? "Basic":"basic";
                String encodedValue = authValue.split(splitter)[1];
                String decodedValue = new String(Base64.decodeBase64(encodedValue));  
                String[] credentials = decodedValue.split(":");
                String clientId = credentials[0];
                String clientSecret = credentials[1];
                
                userAccount = userAccountManager.getUserAccount(clientId);
                
                if (userAccount == null)
                    throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user not authorized ");
            
                if (!clientSecret.equals(userAccount.getPassword()))
                    throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Invalid credentials");
                
            }
            else
                throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; unrecognized authorization method.");
            
            if(!isCsr(userAccount)){
                if(!checkAccess(request, method, userAccount)){
                    throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user not authorized ");
                }
            }
            
            userContextHolder = new UserContextHolder(userAccount);
            request.setAttribute(Key.get(UserContextHolder.class, Names.named("userContextHolder")).toString(), userContextHolder);
            request.setAttribute(Key.get(ApiTransaction.class, Names.named("transaction")).toString(), new ApiTransaction(userAccount));
        }
        else
            throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; request not authorized ");
    }
    
    private boolean checkAccess(HttpRequest request, ResourceMethod resourceMethod, UserAccount userAccount){
        try{
            
            if(resourceMethod.getMethod().isAnnotationPresent(Verifier.class)){
                Class<?> declaringClass = resourceMethod.getMethod().getAnnotation(Verifier.class).clazz();
                String expression =  resourceMethod.getMethod().getAnnotation(Verifier.class).exp();
                int groups = resourceMethod.getMethod().getAnnotation(Verifier.class).groups();
                String[] value = getPathParam(expression, request.getUri().getPath(),groups);
                if(value!=null && value.length > 0){
                    Method[] methods = declaringClass.getMethods();
                    for (Method method : methods){
                        if (method.getName().equals("verify")){
                           return (Boolean)method.invoke(injector.getInstance(declaringClass), request, value, userAccount);
                        }
                    }  
                }
            }  
        }catch(Throwable t){
            logger.error("Exception thrown when checking access: %s ", ExceptionUtils.getStackTrace(t));
        }
        return true;
    }
    
    private boolean isCsr(UserAccount userAccount){
        List<Role> roles = userAccountManager.getUserAcccountRoles((Long) userAccount.getId());
        for (Iterator<Role> iterator = roles.iterator(); iterator.hasNext();)
        {
            Role role = (Role) iterator.next();
            if(role.getRoleName().equals(Roles.CSR.getDisplayName()))
                return true;
        }
        return false;
    }
    
    private String[] getPathParam(String exp, String url, int groups) {
        List<String> params = new ArrayList<String>();
        Pattern p = Pattern.compile(exp);
        Matcher m = p.matcher(url);
        while(m.find()) {
           for (int i = 1; i <= groups; i++){
               params.add(m.group(i));
           }
           return params.toArray(new String[0]);
        }
        return null;
    }

    /**
     * Check user roles & permissions.
     * 
     * @param user
     * @param method
     * @throws WebApplicationException
     */
    private void checkUserRoles(UserAccount user, ResourceMethod method, Long requestId) throws WebApplicationException
    {
        Class<?> declaring = method.getResourceClass();
        Method methodInvoked = method.getMethod();

        String[] rolesAllowed = null;
        boolean denyAll;
        boolean permitAll;
        RolesAllowed allowed = (RolesAllowed) declaring.getAnnotation(RolesAllowed.class);
        RolesAllowed methodAllowed = methodInvoked.getAnnotation(RolesAllowed.class);

        if (methodAllowed != null)
            allowed = methodAllowed;
        if (allowed != null)
            rolesAllowed = allowed.value();

        denyAll = (declaring.isAnnotationPresent(DenyAll.class) && methodInvoked.isAnnotationPresent(RolesAllowed.class) == false && methodInvoked.isAnnotationPresent(PermitAll.class) == false) || methodInvoked.isAnnotationPresent(DenyAll.class);

        permitAll = (declaring.isAnnotationPresent(PermitAll.class) == true && methodInvoked.isAnnotationPresent(RolesAllowed.class) == false && methodInvoked.isAnnotationPresent(DenyAll.class) == false) || methodInvoked.isAnnotationPresent(PermitAll.class);

        if (rolesAllowed != null || denyAll || permitAll)
        {
            if (denyAll)
                throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user does not have permission to access the resource.");

            if (permitAll)
                return;

            if (rolesAllowed != null)
            {
                List<Role> roles = userAccountManager.getUserAcccountRoles((Long) user.getId());

                for (Iterator<Role> iterator = roles.iterator(); iterator.hasNext();)
                {
                    Role accountRole = (Role) iterator.next();
                    
                    if (Role.Roles.Admin.name().equalsIgnoreCase(accountRole.getRoleName()))
                        return;
                    
                    for (String role : rolesAllowed)
                    {
                        if (accountRole.getRoleName().equals(role))
                            return;
                    }
                }
                throw new CustomWebApplicationException(HttpURLConnection.HTTP_UNAUTHORIZED, "Request #" + requestId + " rejected; user does not have permission to access the resource.");
            }
        }
    }
    
    private void setBasicCache()
    {
        String key = Key.get(UserContextHolder.class, Names.named("basicCache")).toString();
        if(req.getSession().getAttribute(key) ==null)
        {
            req.getSession().setAttribute(key, new BasicCache());
        }
    }
    
    public static void main(String[] args)
    {
        String exp="/v1/dashboard/([^<]*)/billings/([^<]*)/waterServices";
        String url ="/v1/dashboard/13113/billings/123123/waterServices";
        Pattern p = Pattern.compile(exp);
        Matcher m = p.matcher(url);
        while(m.find()) {
          System.out.println(m.group(2));
        }
    }
}



